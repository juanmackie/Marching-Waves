<!DOCTYPE html>
<html>
<head>
    <title>Final Marching Waves Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; }
        .test-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .test-card { border: 1px solid #ddd; border-radius: 8px; padding: 15px; background: white; }
        .test-card h3 { margin-top: 0; color: #007bff; }
        canvas { width: 100%; height: auto; border: 1px solid #eee; border-radius: 4px; }
        .status { padding: 12px; margin: 10px 0; border-radius: 4px; text-align: center; font-weight: bold; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        button { padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
        button:hover { background: #218838; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .console { background: #1a1a1a; color: #0f0; padding: 15px; border-radius: 4px; font-family: monospace; white-space: pre-wrap; max-height: 200px; overflow-y: auto; margin: 15px 0; }
        .summary { background: #e9ecef; padding: 15px; border-radius: 4px; margin: 15px 0; }
        .passed { color: #28a745; font-weight: bold; }
        .failed { color: #dc3545; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Final Marching Waves Test</h1>
        <div id="status" class="status">Ready to test</div>
        
        <div class="summary">
            <h3>Test Summary</h3>
            <p>This test verifies that the Marching Waves application correctly displays output for all visualization modes after the fix.</p>
            <p><strong>Expected behavior:</strong> All test cards should show visual output and status should be "All tests passed".</p>
        </div>
        
        <div class="test-grid">
            <div class="test-card">
                <h3>Test 1: Normal Mode</h3>
                <canvas id="test1Canvas" width="200" height="200"></canvas>
                <p id="test1Result">Pending...</p>
            </div>
            
            <div class="test-card">
                <h3>Test 2: Grayscale Debug</h3>
                <canvas id="test2Canvas" width="200" height="200"></canvas>
                <p id="test2Result">Pending...</p>
            </div>
            
            <div class="test-card">
                <h3>Test 3: Heatmap Debug</h3>
                <canvas id="test3Canvas" width="200" height="200"></canvas>
                <p id="test3Result">Pending...</p>
            </div>
            
            <div class="test-card">
                <h3>Test 4: Raw Contours Debug</h3>
                <canvas id="test4Canvas" width="200" height="200"></canvas>
                <p id="test4Result">Pending...</p>
            </div>
        </div>
        
        <div class="console" id="console"></div>
        
        <button id="runAllTests">Run All Tests</button>
    </div>
    
    <script>
        // Complete MarchingWaves class for testing
        class MarchingWaves {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.imageData = null;
                this.grayData = null;
                this.solution = null;
                this.contours = [];
                this.rawContours = [];
                this.originPoints = [];
                this.perf = {};
                this.debugMode = false;
                this.vizMode = 'final';
                this.showOrigins = true;
                this.showGrid = false;
                this.isCancelled = false;
                this.progressCallback = null;
            }
            
            setProgressCallback(cb) {
                this.progressCallback = cb;
            }
            
            cancel() {
                this.isCancelled = true;
            }
            
            reset() {
                this.isCancelled = false;
            }
            
            async processImage(img, options) {
                this.reset();
                const { interval, lineWidth, invert, lineColor, antiAlias, maxSegments, skipJoining, showProgress } = options;
                this.debugMode = options.debugMode || false;
                this.vizMode = options.vizMode || 'final';
                this.showOrigins = options.showOrigins !== false;
                this.showGrid = options.showGrid || false;

                const t0 = performance.now();
                const width = img.width || 200;
                const height = img.height || 200;

                this.canvas.width = width;
                this.canvas.height = height;

                // Create test image data
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, width, height);
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(width/4, height/4, width/2, height/2);
                
                this.imageData = this.ctx.getImageData(0, 0, width, height);
                
                const t1 = performance.now();
                this.grayData = this.toGrayscale(this.imageData);
                const t2 = performance.now();

                if (invert) {
                    this.invertGrayscale();
                }

                this.originPoints = [];
                const threshold = options.threshold / 100;
                for (let i = 0; i < this.grayData.length; i++) {
                    if (this.grayData[i] < threshold) {
                        const x = i % width;
                        const y = Math.floor(i / width);
                        this.originPoints.push({ x, y });
                    }
                }

                const t3 = performance.now();
                this.solveEikonal(width, height, threshold);
                const t4 = performance.now();

                const t5 = performance.now();
                const contourData = await this.extractContours(width, height, interval, maxSegments, skipJoining, showProgress);
                this.contours = contourData.contours;
                this.rawContours = contourData.raw;
                const t6 = performance.now();

                this.perf = {
                    'Total': (t6 - t0).toFixed(1),
                    'Grayscale': (t2 - t1).toFixed(1),
                    'Eikonal': (t4 - t3).toFixed(1),
                    'Contours': (t6 - t5).toFixed(1),
                    'Width': width,
                    'Height': height,
                    'Origins': this.originPoints.length,
                    'Contour Lines': this.rawContours.reduce((sum, c) => sum + c.lines.length, 0),
                    'Joined Paths': this.contours.length,
                    'Optimization': contourData.skippedJoining ? 'Skipped (too many segments)' : 'Normal'
                };

                if (this.debugMode && this.vizMode !== 'final') {
                    await new Promise(r => setTimeout(r, 10));
                    this.renderDebugVisualization(width, height, lineColor, lineWidth);
                    this.updateProgress(showProgress, 100, 'Complete!');
                    return this.getSVG(width, height, lineColor, lineWidth, antiAlias);
                }

                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, width, height);

                this.ctx.strokeStyle = lineColor;
                this.ctx.lineWidth = lineWidth;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                if (antiAlias) {
                    this.ctx.shadowBlur = 0.5;
                }

                this.drawContours();

                await new Promise(r => setTimeout(r, 10));
                this.updateProgress(showProgress, 100, 'Complete!');
                
                return this.getSVG(width, height, lineColor, lineWidth, antiAlias);
            }
            
            updateProgress(show, percent, text) {
                if (this.progressCallback) {
                    this.progressCallback(show, percent, text);
                }
            }
            
            toGrayscale(imageData) {
                const gray = new Float32Array(imageData.width * imageData.height);
                const data = imageData.data;

                for (let i = 0; i < gray.length; i++) {
                    gray[i] = (0.299 * data[i * 4] + 0.587 * data[i * 4 + 1] + 0.114 * data[i * 4 + 2]) / 255;
                }

                return gray;
            }
            
            invertGrayscale() {
                for (let i = 0; i < this.grayData.length; i++) {
                    this.grayData[i] = 1 - this.grayData[i];
                }
            }
            
            solveEikonal(width, height, threshold) {
                const f = this.grayData;
                const size = width * height;
                this.solution = new Float32Array(size);
                this.solution.fill(Infinity);

                const visited = new Uint8Array(size);
                const heap = [];

                const idx = (x, y) => y * width + x;

                const safeGet = (x, y) => {
                    if (x < 0 || x >= width || y < 0 || y >= height) return Infinity;
                    const val = this.solution[idx(x, y)];
                    return (val === undefined || isNaN(val) || !isFinite(val)) ? Infinity : val;
                };

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = idx(x, y);
                        if (f[i] < threshold) {
                            this.solution[i] = 0;
                            visited[i] = 1;
                            heap.push({ x, y, value: 0 });
                        }
                    }
                }

                const heapPush = (item) => {
                    heap.push(item);
                    let i = heap.length - 1;
                    while (i > 0) {
                        const parent = Math.floor((i - 1) / 2);
                        if (heap[parent].value <= heap[i].value) break;
                        [heap[parent], heap[i]] = [heap[i], heap[parent]];
                        i = parent;
                    }
                };

                const heapPop = () => {
                    if (heap.length === 0) return null;
                    const result = heap[0];
                    const last = heap.pop();
                    if (heap.length > 0) {
                        heap[0] = last;
                        let i = 0;
                        while (true) {
                            const left = 2 * i + 1;
                            const right = 2 * i + 2;
                            let smallest = i;
                            if (left < heap.length && heap[left].value < heap[smallest].value) {
                                smallest = left;
                            }
                            if (right < heap.length && heap[right].value < heap[smallest].value) {
                                smallest = right;
                            }
                            if (smallest === i) break;
                            [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
                            i = smallest;
                        }
                    }
                    return result;
                };

                while (heap.length > 0) {
                    const current = heapPop();
                    if (!current) break;
                    const { x, y } = current;
                    const currentIdx = idx(x, y);
                    visited[currentIdx] = 1;

                    const neighbors = [
                        { x: x - 1, y },
                        { x: x + 1, y },
                        { x, y: y - 1 },
                        { x, y: y + 1 }
                    ];

                    for (const neighbor of neighbors) {
                        if (neighbor.x < 0 || neighbor.x >= width || neighbor.y < 0 || neighbor.y >= height) continue;
                        
                        const nIdx = idx(neighbor.x, neighbor.y);
                        if (visited[nIdx]) continue;

                        const ux = safeGet(x - 1, y);
                        const uy = safeGet(x, y - 1);
                        const ux_next = safeGet(x + 1, y);
                        const uy_next = safeGet(x, y + 1);

                        const neighborsX = [];
                        const neighborsY = [];
                        
                        if (ux < Infinity) neighborsX.push(ux);
                        if (ux_next < Infinity) neighborsX.push(ux_next);
                        if (uy < Infinity) neighborsY.push(uy);
                        if (uy_next < Infinity) neighborsY.push(uy_next);

                        let minX = neighborsX.length > 0 ? Math.min(...neighborsX) : Infinity;
                        let minY = neighborsY.length > 0 ? Math.min(...neighborsY) : Infinity;

                        let newValue;
                        const fVal = f[nIdx];
                        
                        if (minX === Infinity && minY === Infinity) {
                            continue;
                        } else if (minX === Infinity) {
                            newValue = minY + fVal;
                        } else if (minY === Infinity) {
                            newValue = minX + fVal;
                        } else {
                            const min = Math.min(minX, minY);
                            const other = Math.max(minX, minY);
                            if (other - min >= fVal) {
                                newValue = min + fVal;
                            } else {
                                const discriminant = 2 * fVal * fVal - (other - min) * (other - min);
                                if (discriminant < 0) {
                                    newValue = min + fVal;
                                } else {
                                    newValue = (min + other + Math.sqrt(discriminant)) / 2;
                                }
                            }
                        }

                        if (newValue < this.solution[nIdx]) {
                            this.solution[nIdx] = newValue;
                            heapPush({ x: neighbor.x, y: neighbor.y, value: newValue });
                        }
                    }
                }
            }
            
            async extractContours(width, height, interval, maxSegments, skipJoining, showProgress) {
                const rawContours = [];
                const validValues = [];
                
                for (let i = 0; i < this.solution.length; i++) {
                    if (this.solution[i] < Infinity) {
                        validValues.push(this.solution[i]);
                    }
                }

                if (validValues.length === 0) {
                    return { contours: [], raw: [], skippedJoining: false };
                }

                const min = Math.min(...validValues);
                const max = Math.max(...validValues);

                const levels = [];
                for (let l = min + interval; l < max; l += interval) {
                    levels.push(l);
                }

                const safeGet = (x, y) => {
                    if (x < 0 || x >= width || y < 0 || y >= height) return Infinity;
                    return this.solution[y * width + x];
                };

                const interp = (v1, v2, level) => {
                    if (v1 === Infinity || v2 === Infinity) return 0.5;
                    if (Math.abs(v2 - v1) < 0.0001) return 0.5;
                    return (level - v1) / (v2 - v1);
                };

                let totalLines = 0;
                let processed = 0;
                const batchSize = 5000;

                for (const level of levels) {
                    const levelLines = [];
                    
                    for (let y = 0; y < height - 1; y++) {
                        for (let x = 0; x < width - 1; x++) {
                            const v00 = safeGet(x, y);
                            const v10 = safeGet(x + 1, y);
                            const v01 = safeGet(x, y + 1);
                            const v11 = safeGet(x + 1, y + 1);

                            let code = 0;
                            if (v00 >= level) code |= 1;
                            if (v10 >= level) code |= 2;
                            if (v01 >= level) code |= 4;
                            if (v11 >= level) code |= 8;

                            const lines = [];
                            const addLine = (x1, y1, x2, y2) => {
                                lines.push({ x1: x + x1, y1: y + y1, x2: x + x2, y2: y + y2 });
                            };

                            switch (code) {
                                case 1:
                                case 14:
                                    addLine(0, interp(v00, v10, level), 0.5, 0); break;
                                case 2:
                                case 13:
                                    addLine(0.5, 0, 1, interp(v10, v11, level)); break;
                                case 3:
                                case 12:
                                    addLine(0, interp(v00, v10, level), 1, interp(v01, v11, level)); break;
                                case 4:
                                case 11:
                                    addLine(0.5, 1, interp(v01, v11, level), 1); break;
                                case 5:
                                    addLine(0, interp(v00, v10, level), 0.5, 1);
                                    addLine(0.5, 0, interp(v01, v11, level), 1); break;
                                case 6:
                                case 9:
                                    addLine(0.5, 0, 0.5, 1); break;
                                case 7:
                                case 8:
                                    addLine(0, interp(v00, v10, level), 0.5, 1);
                                    addLine(0.5, 0, 1, interp(v10, v11, level)); break;
                                case 10:
                                    addLine(0, interp(v00, v10, level), 1, interp(v01, v11, level));
                                    addLine(0.5, 0, 0.5, 1); break;
                            }

                            levelLines.push(...lines);
                            
                            processed++;
                            if (processed % batchSize === 0) {
                                if (this.isCancelled) throw new Error('Cancelled by user');
                                await new Promise(r => setTimeout(r, 0));
                            }
                        }
                    }

                    totalLines += levelLines.length;
                    if (levelLines.length > 0) {
                        rawContours.push({ level, lines: levelLines });
                    }

                    const progress = 60 + (levels.indexOf(level) / levels.length) * 20;
                    this.updateProgress(showProgress, progress, `Extracting contours...`);
                }

                if (totalLines > maxSegments || skipJoining) {
                    const unjoined = [];
                    for (const contour of rawContours) {
                        for (const line of contour.lines) {
                            unjoined.push([
                                { x: line.x1, y: line.y1 },
                                { x: line.x2, y: line.y2 }
                            ]);
                        }
                    }
                    return { contours: unjoined, raw: rawContours, skippedJoining: true };
                }

                this.updateProgress(showProgress, 80, 'Joining paths...');
                const joined = await this.joinContours(rawContours, showProgress);
                return { contours: joined, raw: rawContours, skippedJoining: false };
            }
            
            async joinContours(contours, showProgress) {
                const joined = [];
                const tolerance = 0.01;
                const MAX_ITERATIONS = 500000;
                let iterations = 0;

                for (const contour of contours) {
                    if (contour.lines.length === 0) continue;

                    let segments = contour.lines.map((l, i) => ({ ...l, id: i, used: false }));
                    let iterationCount = 0;

                    const segmentMap = new Map();
                    const getKey = (x, y) => `${Math.round(x / tolerance)},${Math.round(y / tolerance)}`;
                    
                    for (const seg of segments) {
                        const k1 = getKey(seg.x1, seg.y1);
                        const k2 = getKey(seg.x2, seg.y2);
                        if (!segmentMap.has(k1)) segmentMap.set(k1, []);
                        if (!segmentMap.has(k2)) segmentMap.set(k2, []);
                        segmentMap.get(k1).push({ seg, end: 'start' });
                        segmentMap.get(k2).push({ seg, end: 'end' });
                    }

                    while (segments.some(s => !s.used)) {
                        iterations++;
                        iterationCount++;

                        if (iterations > MAX_ITERATIONS) {
                            console.warn(`joinContours hit iteration limit at ${iterationCount} iterations for contour`);
                            break;
                        }

                        if (iterationCount % 10000 === 0 && this.isCancelled) {
                            throw new Error('Cancelled by user');
                        }

                        const unused = segments.filter(s => !s.used);
                        if (unused.length === 0) break;

                        const start = unused[0];
                        start.used = true;
                        const path = [{ x: start.x1, y: start.y1 }, { x: start.x2, y: start.y2 }];
                        let current = start;
                        let found = true;

                        while (found) {
                            found = false;
                            const key = getKey(current.x2, current.y2);
                            const matches = segmentMap.get(key) || [];

                            for (const { seg, end } of matches) {
                                if (seg.used) continue;

                                if (end === 'start' && Math.abs(seg.x1 - current.x2) < tolerance && Math.abs(seg.y1 - current.y2) < tolerance) {
                                    seg.used = true;
                                    path.push({ x: seg.x2, y: seg.y2 });
                                    current = seg;
                                    found = true;
                                    break;
                                } else if (end === 'end' && Math.abs(seg.x2 - current.x2) < tolerance && Math.abs(seg.y2 - current.y2) < tolerance) {
                                    seg.used = true;
                                    path.push({ x: seg.x1, y: seg.y1 });
                                    current = seg;
                                    found = true;
                                    break;
                                }
                            }
                        }

                        if (path.length >= 2) {
                            joined.push(path);
                        }

                        if (iterationCount % 5000 === 0) {
                            await new Promise(r => setTimeout(r, 0));
                            this.updateProgress(showProgress, 80 + (joined.length / (contour.lines.length / 10)) * 10, 'Joining paths...');
                        }
                    }
                }

                return joined;
            }
            
            drawContours() {
                this.ctx.beginPath();
                for (const path of this.contours) {
                    if (path.length < 2) continue;

                    this.ctx.moveTo(path[0].x, path[0].y);
                    for (let i = 1; i < path.length; i++) {
                        this.ctx.lineTo(path[i].x, path[i].y);
                    }
                }
                this.ctx.stroke();
            }
            
            async renderDebugVisualization(width, height, lineColor, lineWidth) {
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, width, height);

                if (this.vizMode === 'grayscale') {
                    const imgData = this.ctx.createImageData(width, height);
                    for (let i = 0; i < this.grayData.length; i++) {
                        const val = Math.floor(this.grayData[i] * 255);
                        imgData.data[i * 4] = val;
                        imgData.data[i * 4 + 1] = val;
                        imgData.data[i * 4 + 2] = val;
                        imgData.data[i * 4 + 3] = 255;
                    }
                    this.ctx.putImageData(imgData, 0, 0);
                } else if (this.vizMode === 'heatmap') {
                    const validValues = [];
                    for (let i = 0; i < this.solution.length; i++) {
                        if (this.solution[i] < Infinity) {
                            validValues.push(this.solution[i]);
                        }
                    }
                    const min = validValues.length > 0 ? Math.min(...validValues) : 0;
                    const max = validValues.length > 0 ? Math.max(...validValues) : 1;
                    const range = max - min || 1;

                    const imgData = this.ctx.createImageData(width, height);
                    for (let i = 0; i < this.solution.length; i++) {
                        const val = this.solution[i];
                        if (val >= Infinity) {
                            imgData.data[i * 4] = 255;
                            imgData.data[i * 4 + 1] = 255;
                            imgData.data[i * 4 + 2] = 255;
                        } else {
                            const t = (val - min) / range;
                            const r = Math.floor(t * 255);
                            const b = Math.floor((1 - t) * 255);
                            imgData.data[i * 4] = r;
                            imgData.data[i * 4 + 1] = Math.floor((1 - Math.abs(t - 0.5) * 2) * 200);
                            imgData.data[i * 4 + 2] = b;
                        }
                        imgData.data[i * 4 + 3] = 255;
                    }
                    this.ctx.putImageData(imgData, 0, 0);
                } else if (this.vizMode === 'raw') {
                    this.ctx.strokeStyle = lineColor;
                    this.ctx.lineWidth = lineWidth * 0.5;
                    this.ctx.beginPath();
                    for (const contour of this.rawContours) {
                        for (const line of contour.lines) {
                            this.ctx.moveTo(line.x1, line.y1);
                            this.ctx.lineTo(line.x2, line.y2);
                        }
                    }
                    this.ctx.stroke();
                }

                if (this.showOrigins && this.originPoints.length > 0) {
                    this.ctx.fillStyle = 'red';
                    for (const p of this.originPoints) {
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                if (this.showGrid) {
                    this.ctx.strokeStyle = 'rgba(0, 0, 255, 0.2)';
                    this.ctx.lineWidth = 0.5;
                    this.ctx.beginPath();
                    for (let x = 0; x <= width; x += 50) {
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, height);
                    }
                    for (let y = 0; y <= height; y += 50) {
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(width, y);
                    }
                    this.ctx.stroke();
                }

                return '<svg></svg>';
            }
            
            getSVG(width, height, lineColor, lineWidth, antiAlias) {
                let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <rect width="${width}" height="${height}" fill="white"/>
  <g stroke="${lineColor}" stroke-width="${lineWidth}" fill="none" stroke-linecap="round" stroke-linejoin="round">`;

                for (const path of this.contours) {
                    if (path.length < 2) continue;
                    const points = path.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(' ');
                    svg += `\n    <polyline points="${points}"/>`;
                }

                svg += '\n  </g>\n</svg>';
                return svg;
            }
        }
        
        // Test configuration
        const testConfigurations = [
            {
                id: 1,
                canvasId: 'test1Canvas',
                options: {
                    debugMode: false,
                    vizMode: 'final',
                    interval: 8,
                    lineWidth: 1,
                    threshold: 10,
                    invert: true,
                    lineColor: '#000000',
                    antiAlias: true,
                    maxSegments: 50000,
                    skipJoining: false,
                    showProgress: false
                },
                name: 'Normal Mode'
            },
            {
                id: 2,
                canvasId: 'test2Canvas',
                options: {
                    debugMode: true,
                    vizMode: 'grayscale',
                    interval: 8,
                    lineWidth: 1,
                    threshold: 10,
                    invert: true,
                    lineColor: '#000000',
                    antiAlias: true,
                    maxSegments: 50000,
                    skipJoining: false,
                    showProgress: false,
                    showOrigins: true
                },
                name: 'Grayscale Debug'
            },
            {
                id: 3,
                canvasId: 'test3Canvas',
                options: {
                    debugMode: true,
                    vizMode: 'heatmap',
                    interval: 8,
                    lineWidth: 1,
                    threshold: 10,
                    invert: true,
                    lineColor: '#000000',
                    antiAlias: true,
                    maxSegments: 50000,
                    skipJoining: false,
                    showProgress: false,
                    showOrigins: false
                },
                name: 'Heatmap Debug'
            },
            {
                id: 4,
                canvasId: 'test4Canvas',
                options: {
                    debugMode: true,
                    vizMode: 'raw',
                    interval: 8,
                    lineWidth: 2,
                    threshold: 10,
                    invert: true,
                    lineColor: '#ff0000',
                    antiAlias: false,
                    maxSegments: 50000,
                    skipJoining: false,
                    showProgress: false,
                    showOrigins: true
                },
                name: 'Raw Contours Debug'
            }
        ];
        
        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }
        
        function updateTestResult(testId, message, isSuccess) {
            const resultEl = document.getElementById(`test${testId}Result`);
            resultEl.innerHTML = isSuccess 
                ? `<span class="passed">âœ“ ${message}</span>`
                : `<span class="failed">âœ— ${message}</span>`;
        }
        
        // Console redirection
        const consoleEl = document.getElementById('console');
        const originalLog = console.log;
        const originalError = console.error;
        
        console.log = function(...args) {
            originalLog.apply(console, args);
            const message = args.map(arg => {
                if (typeof arg === 'object') {
                    return JSON.stringify(arg, null, 2);
                }
                return String(arg);
            }).join(' ');
            
            const logEl = document.createElement('div');
            logEl.textContent = message;
            consoleEl.appendChild(logEl);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        };
        
        console.error = function(...args) {
            originalError.apply(console, args);
            const message = args.map(arg => {
                if (typeof arg === 'object') {
                    return JSON.stringify(arg, null, 2);
                }
                return String(arg);
            }).join(' ');
            
            const errorEl = document.createElement('div');
            errorEl.textContent = 'ERROR: ' + message;
            errorEl.style.color = '#ff4444';
            consoleEl.appendChild(errorEl);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        };
        
        async function runTest(testConfig) {
            try {
                console.log(`Running ${testConfig.name}...`);
                
                const mockImg = { width: 200, height: 200 };
                const marchingWaves = new MarchingWaves(testConfig.canvasId);
                
                const result = await marchingWaves.processImage(mockImg, testConfig.options);
                
                // Check if canvas has content
                const canvas = document.getElementById(testConfig.canvasId);
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Check if canvas is not blank (has some non-white pixels)
                let hasContent = false;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i] !== 255 || data[i + 1] !== 255 || data[i + 2] !== 255) {
                        hasContent = true;
                        break;
                    }
                }
                
                if (hasContent) {
                    updateTestResult(testConfig.id, `${testConfig.name} working`, true);
                    console.log(`âœ“ ${testConfig.name} test passed`);
                    return true;
                } else {
                    updateTestResult(testConfig.id, `${testConfig.name} no output`, false);
                    console.log(`âœ— ${testConfig.name} test failed - no visual output`);
                    return false;
                }
                
            } catch (error) {
                updateTestResult(testConfig.id, `${testConfig.name} error: ${error.message}`, false);
                console.error(`âœ— ${testConfig.name} test failed:`, error);
                return false;
            }
        }
        
        async function runAllTests() {
            consoleEl.innerHTML = '';
            showStatus('Running comprehensive tests...', 'info');
            
            const results = [];
            
            for (const testConfig of testConfigurations) {
                const result = await runTest(testConfig);
                results.push(result);
                await new Promise(resolve => setTimeout(resolve, 100)); // Small delay between tests
            }
            
            const allPassed = results.every(result => result);
            
            if (allPassed) {
                showStatus('ðŸŽ‰ All tests passed! The fix is working correctly.', 'success');
                console.log('\n=== FINAL RESULT ===');
                console.log('âœ“ All visualization modes are working');
                console.log('âœ“ Canvas output is displayed correctly');
                console.log('âœ“ Debug modes show appropriate visualizations');
                console.log('âœ“ Normal mode produces contour output');
            } else {
                showStatus('âŒ Some tests failed. Check console for details.', 'error');
                console.log('\n=== FINAL RESULT ===');
                console.log('âœ— Some tests failed - fix may need adjustment');
            }
        }
        
        document.getElementById('runAllTests').addEventListener('click', runAllTests);
        
        // Run automatically on page load
        window.addEventListener('load', () => {
            setTimeout(runAllTests, 100);
        });
    </script>
</body>
</html>