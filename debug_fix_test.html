<!DOCTYPE html>
<html>
<head>
    <title>Debug Fix Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 4px; }
        canvas { border: 1px solid #ccc; background: white; margin: 10px 0; max-width: 100%; }
        .status { padding: 12px; margin: 10px 0; border-radius: 4px; text-align: center; font-weight: bold; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        button { padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
        button:hover { background: #218838; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .console { background: #1a1a1a; color: #0f0; padding: 15px; border-radius: 4px; font-family: monospace; white-space: pre-wrap; max-height: 200px; overflow-y: auto; margin: 15px 0; }
        .result { padding: 10px; background: #e9ecef; border-radius: 4px; margin: 10px 0; }
        .passed { color: #28a745; font-weight: bold; }
        .failed { color: #dc3545; font-weight: bold; }
        select, input { padding: 8px; margin: 5px 0; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Debug Fix Test</h1>
        <div id="status" class="status">Ready to test</div>
        
        <div class="test-section">
            <h3>Test Configuration</h3>
            <div>
                <label for="modeSelect">Visualization Mode:</label>
                <select id="modeSelect">
                    <option value="final">Normal (Final)</option>
                    <option value="grayscale">Debug (Grayscale)</option>
                    <option value="heatmap">Debug (Heatmap)</option>
                    <option value="raw">Debug (Raw Contours)</option>
                </select>
            </div>
            <div>
                <label for="debugCheck">Debug Mode:</label>
                <input type="checkbox" id="debugCheck">
            </div>
            <div>
                <label for="originsCheck">Show Origins:</label>
                <input type="checkbox" id="originsCheck" checked>
            </div>
        </div>
        
        <div class="test-section">
            <h3>Test Canvas</h3>
            <canvas id="testCanvas" width="200" height="200"></canvas>
            <div id="testResult" class="result">Pending test...</div>
        </div>
        
        <div class="console" id="console"></div>
        
        <button id="runTest">Run Test</button>
    </div>
    
    <script>
        // Focused test for the debug visualization fix
        class DebugTestMarchingWaves {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.debugMode = false;
                this.vizMode = 'final';
                this.showOrigins = true;
            }
            
            async processImage(options) {
                this.debugMode = options.debugMode || false;
                this.vizMode = options.vizMode || 'final';
                this.showOrigins = options.showOrigins !== false;
                
                const width = 200;
                const height = 200;
                this.canvas.width = width;
                this.canvas.height = height;
                
                console.log(`Processing with mode: ${this.vizMode}, debug: ${this.debugMode}`);
                
                if (this.debugMode && this.vizMode !== 'final') {
                    // This is the key fix - renderDebugVisualization should render to canvas
                    // and the method should continue to return SVG
                    console.log('Calling renderDebugVisualization...');
                    this.renderDebugVisualization(width, height, options.lineColor, options.lineWidth);
                    console.log('renderDebugVisualization completed');
                    
                    // This should not prevent the method from continuing
                    const svg = this.getSVG(width, height, options.lineColor, options.lineWidth, options.antiAlias);
                    console.log('SVG generated, length:', svg.length);
                    return svg;
                }
                
                // Normal mode - draw simple test pattern
                console.log('Normal mode processing');
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, width, height);
                this.ctx.strokeStyle = options.lineColor;
                this.ctx.lineWidth = options.lineWidth;
                this.ctx.beginPath();
                this.ctx.moveTo(50, 50);
                this.ctx.lineTo(150, 150);
                this.ctx.moveTo(50, 150);
                this.ctx.lineTo(150, 50);
                this.ctx.stroke();
                
                return this.getSVG(width, height, options.lineColor, options.lineWidth, options.antiAlias);
            }
            
            renderDebugVisualization(width, height, lineColor, lineWidth) {
                console.log('renderDebugVisualization called with mode:', this.vizMode);
                
                // Clear canvas
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, width, height);
                
                if (this.vizMode === 'grayscale') {
                    console.log('Creating grayscale visualization');
                    // Create a grayscale gradient
                    const imgData = this.ctx.createImageData(width, height);
                    for (let i = 0; i < width * height; i++) {
                        const val = Math.floor((i / (width * height)) * 255);
                        imgData.data[i * 4] = val;
                        imgData.data[i * 4 + 1] = val;
                        imgData.data[i * 4 + 2] = val;
                        imgData.data[i * 4 + 3] = 255;
                    }
                    this.ctx.putImageData(imgData, 0, 0);
                } else if (this.vizMode === 'heatmap') {
                    console.log('Creating heatmap visualization');
                    // Create a heatmap gradient
                    const imgData = this.ctx.createImageData(width, height);
                    for (let i = 0; i < width * height; i++) {
                        const x = i % width;
                        const y = Math.floor(i / width);
                        const t = (x + y) / (width + height);
                        const r = Math.floor(t * 255);
                        const b = Math.floor((1 - t) * 255);
                        imgData.data[i * 4] = r;
                        imgData.data[i * 4 + 1] = 0;
                        imgData.data[i * 4 + 2] = b;
                        imgData.data[i * 4 + 3] = 255;
                    }
                    this.ctx.putImageData(imgData, 0, 0);
                } else if (this.vizMode === 'raw') {
                    console.log('Creating raw contour visualization');
                    // Draw grid lines
                    this.ctx.strokeStyle = lineColor;
                    this.ctx.lineWidth = lineWidth * 0.5;
                    this.ctx.beginPath();
                    
                    // Draw horizontal lines
                    for (let y = 20; y < height; y += 20) {
                        this.ctx.moveTo(10, y);
                        this.ctx.lineTo(width - 10, y);
                    }
                    
                    // Draw vertical lines
                    for (let x = 20; x < width; x += 20) {
                        this.ctx.moveTo(x, 10);
                        this.ctx.lineTo(x, height - 10);
                    }
                    
                    this.ctx.stroke();
                }
                
                // Show origin points if enabled
                if (this.showOrigins) {
                    console.log('Adding origin points');
                    this.ctx.fillStyle = 'red';
                    for (let i = 0; i < 5; i++) {
                        const x = Math.random() * width;
                        const y = Math.random() * height;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                return '<svg></svg>';
            }
            
            getSVG(width, height, lineColor, lineWidth, antiAlias) {
                return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <rect width="${width}" height="${height}" fill="white"/>
  <g stroke="${lineColor}" stroke-width="${lineWidth}" fill="none">
    <line x1="50" y1="50" x2="150" y2="150"/>
    <line x1="50" y1="150" x2="150" y2="50"/>
  </g>
</svg>`;
            }
        }
        
        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }
        
        function updateTestResult(message, isSuccess) {
            const resultEl = document.getElementById('testResult');
            resultEl.innerHTML = isSuccess 
                ? `<span class="passed">✓ ${message}</span>`
                : `<span class="failed">✗ ${message}</span>`;
        }
        
        // Console redirection
        const consoleEl = document.getElementById('console');
        const originalLog = console.log;
        const originalError = console.error;
        
        console.log = function(...args) {
            originalLog.apply(console, args);
            const message = args.map(arg => {
                if (typeof arg === 'object') {
                    return JSON.stringify(arg, null, 2);
                }
                return String(arg);
            }).join(' ');
            
            const logEl = document.createElement('div');
            logEl.textContent = message;
            consoleEl.appendChild(logEl);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        };
        
        console.error = function(...args) {
            originalError.apply(console, args);
            const message = args.map(arg => {
                if (typeof arg === 'object') {
                    return JSON.stringify(arg, null, 2);
                }
                return String(arg);
            }).join(' ');
            
            const errorEl = document.createElement('div');
            errorEl.textContent = 'ERROR: ' + message;
            errorEl.style.color = '#ff4444';
            consoleEl.appendChild(errorEl);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        };
        
        async function runTest() {
            consoleEl.innerHTML = '';
            showStatus('Running debug fix test...', 'info');
            
            try {
                const modeSelect = document.getElementById('modeSelect');
                const debugCheck = document.getElementById('debugCheck');
                const originsCheck = document.getElementById('originsCheck');
                
                const mode = modeSelect.value;
                const debugMode = debugCheck.checked;
                const showOrigins = originsCheck.checked;
                
                console.log(`Test Configuration:`);
                console.log(`- Mode: ${mode}`);
                console.log(`- Debug: ${debugMode}`);
                console.log(`- Show Origins: ${showOrigins}`);
                
                const waves = new DebugTestMarchingWaves('testCanvas');
                
                const options = {
                    debugMode: debugMode,
                    vizMode: mode,
                    lineColor: '#000000',
                    lineWidth: 1,
                    showOrigins: showOrigins
                };
                
                const result = await waves.processImage(options);
                
                // Check if canvas has content
                const ctx = waves.ctx;
                const imageData = ctx.getImageData(0, 0, 200, 200);
                const data = imageData.data;
                
                let hasContent = false;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i] !== 255 || data[i + 1] !== 255 || data[i + 2] !== 255) {
                        hasContent = true;
                        break;
                    }
                }
                
                if (hasContent) {
                    updateTestResult(`Debug fix working! ${mode} mode displays output correctly.`, true);
                    showStatus('✅ Test passed!', 'success');
                    console.log('✓ Canvas has visual content');
                    console.log('✓ Method completed successfully');
                    console.log('✓ SVG generated with length:', result.length);
                } else {
                    updateTestResult(`Test failed! ${mode} mode shows blank canvas.`, false);
                    showStatus('❌ Test failed', 'error');
                    console.log('✗ Canvas is blank');
                }
                
            } catch (error) {
                updateTestResult('Test failed: ' + error.message, false);
                showStatus('❌ Test failed', 'error');
                console.error('Test failed:', error);
            }
        }
        
        // Update debug checkbox based on mode
        document.getElementById('modeSelect').addEventListener('change', function() {
            const debugCheck = document.getElementById('debugCheck');
            debugCheck.checked = this.value !== 'final';
        });
        
        document.getElementById('runTest').addEventListener('click', runTest);
        
        // Run automatically on page load with default settings
        window.addEventListener('load', function() {
            setTimeout(runTest, 100);
        });
    </script>
</body>
</html>