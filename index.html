<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marching Waves Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #fff;
        }

        .subtitle {
            color: #888;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 340px 1fr;
            gap: 20px;
        }

        .sidebar {
            background: #16213e;
            padding: 20px;
            border-radius: 12px;
            height: fit-content;
        }

        .panel {
            margin-bottom: 20px;
        }

        .panel h3 {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 12px;
        }

        .drop-zone {
            border: 2px dashed #444;
            border-radius: 8px;
            padding: 20px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #1a1a2e;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: #00d9ff;
            background: rgba(0, 217, 255, 0.1);
        }

        .drop-zone-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .drop-zone p {
            color: #888;
            font-size: 0.85rem;
        }

        #fileInput {
            display: none;
        }

        .sample-btn {
            width: 100%;
            padding: 8px;
            border: 1px dashed #444;
            border-radius: 6px;
            background: transparent;
            color: #888;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .sample-btn:hover {
            border-color: #00d9ff;
            color: #00d9ff;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            color: #ccc;
            margin-bottom: 6px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
        }

        .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #00d9ff;
            margin-top: 4px;
        }

        /* Info Icon Styles */
        .label-with-info {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }

        .label-with-info label {
            margin-bottom: 0;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            font-size: 14px;
            color: #888;
            cursor: help;
            position: relative;
            transition: color 0.2s ease;
            user-select: none;
        }

        .info-icon:hover,
        .info-icon:focus {
            color: #00d9ff;
            outline: none;
        }

        /* Tooltip Base */
        .info-icon::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            bottom: calc(100% + 8px);
            transform: translateX(-50%) translateY(-4px);
            background: rgba(0, 30, 60, 0.98);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            line-height: 1.4;
            white-space: normal;
            width: 220px;
            text-align: left;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
            border: 1px solid rgba(0, 217, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        /* Tooltip Arrow */
        .info-icon::before {
            content: '';
            position: absolute;
            left: 50%;
            bottom: calc(100% + 2px);
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 30, 60, 0.98);
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s;
        }

        /* Desktop Hover Tooltip */
        @media (hover: hover) and (pointer: fine) {
            .info-icon:hover::after,
            .info-icon:hover::before {
                opacity: 1;
                visibility: visible;
                transform: translateX(-50%) translateY(0);
            }
            }

            detectCorners(points, angleThreshold = 120) {
                if (!points || points.length < 3) return new Set();

                const corners = new Set();
                const thresholdRad = angleThreshold * (Math.PI / 180);

                for (let i = 1; i < points.length - 1; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    const next = points[i + 1];

                    if (!prev || !curr || !next) continue;

                    const v1x = prev.x - curr.x;
                    const v1y = prev.y - curr.y;
                    const v2x = next.x - curr.x;
                    const v2y = next.y - curr.y;

                    const dot = v1x * v2x + v1y * v2y;
                    const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
                    const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);

                    if (mag1 < 0.0001 || mag2 < 0.0001) continue;

                    const cosAngle = dot / (mag1 * mag2);
                    const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));

                    if (angle < thresholdRad) {
                        corners.add(i);
                    }
                }

                return corners;
            }

            getSplinePointsWithCorners(points, segments = 4, tension = 0.5, cornerSet) {
                if (!points || points.length < 2) return this.validatePath(points);

                const validPoints = this.validatePath(points);
                if (validPoints.length < 2) return validPoints;

                if (!cornerSet || cornerSet.size === 0) {
                    return this.getSplinePoints(points, segments, tension);
                }

                const cornerIndices = Array.from(cornerSet).sort((a, b) => a - b);
                if (cornerIndices.length === 0) {
                    return this.getSplinePoints(points, segments, tension);
                }

                const result = [];

                for (let i = 0; i < cornerIndices.length; i++) {
                    const cornerIdx = cornerIndices[i];
                    const prevCornerIdx = i > 0 ? cornerIndices[i - 1] : 0;

                    const segment = validPoints.slice(prevCornerIdx, cornerIdx + 1);

                    if (segment.length >= 2) {
                        const smoothed = this.getSplinePoints(segment, segments, tension);
                        result.push(...smoothed.slice(0, -1));
                    }
                }

                const lastCornerIdx = cornerIndices[cornerIndices.length - 1];
                const lastSegment = validPoints.slice(lastCornerIdx);
                if (lastSegment.length >= 2) {
                    result.push(...this.getSplinePoints(lastSegment, segments, tension));
                } else if (lastSegment.length === 1) {
                    result.push(lastSegment[0]);
                }

                return this.validatePath(result);
            }

            // Catmull-Rom Spline Smoothing
            getSplinePoints(points, segments = 4, tension = 0.5) {
                if (!points || points.length < 2) return this.validatePath(points);

                const validPoints = this.validatePath(points);
                if (validPoints.length < 2) return validPoints;

                const spline = [];
                // Duplicate start and end points for the algorithm
                const p = [validPoints[0], ...validPoints, validPoints[validPoints.length - 1]];

                for (let i = 0; i < p.length - 3; i++) {
                    const p0 = p[i];
                    const p1 = p[i + 1];
                    const p2 = p[i + 2];
                    const p3 = p[i + 3];

                    if (!p0 || !p1 || !p2 || !p3) continue;

                    for (let t = 0; t < segments; t++) {
                        // For the last segment, include the end point
                        if (i === p.length - 4 && t === segments - 1) {
                             spline.push(this.catmullRom(p0, p1, p2, p3, 1.0, tension));
                        } else {
                             const st = t / segments;
                             spline.push(this.catmullRom(p0, p1, p2, p3, st, tension));
                        }
                    }
                }

                // Ensure the very last point is included and exact
                if (spline.length > 0) {
                     const lastSpline = spline[spline.length - 1];
                     const lastPoint = validPoints[validPoints.length - 1];
                     if (lastSpline.x !== lastPoint.x || lastSpline.y !== lastPoint.y) {
                         spline.push(lastPoint);
                     }
                } else {
                    return validPoints;
                }

                return this.validatePath(spline);
            }

            catmullRom(p0, p1, p2, p3, t, tension) {
                const t2 = t * t;
                const t3 = t2 * t;

                const v0 = (p2.x - p0.x) * tension;
                const v1 = (p3.x - p1.x) * tension;
                const x = (2 * p1.x - 2 * p2.x + v0 + v1) * t3 + (-3 * p1.x + 3 * p2.x - 2 * v0 - v1) * t2 + v0 * t + p1.x;

                const u0 = (p2.y - p0.y) * tension;
                const u1 = (p3.y - p1.y) * tension;
                const y = (2 * p1.y - 2 * p2.y + u0 + u1) * t3 + (-3 * p1.y + 3 * p2.y - 2 * u0 - u1) * t2 + u0 * t + p1.y;

                return { x, y };
            }

            getPathLength(path) {
                if (!path || path.length < 2) return 0;

                const validPath = this.validatePath(path);
                if (validPath.length < 2) return 0;

                let len = 0;
                for (let i = 0; i < validPath.length - 1; i++) {
                    len += this.pointDistance(validPath[i], validPath[i+1]);
                }
                return len;
            }

            // Greedy TSP-Lite for Path Optimization
            optimizePathOrder(paths) {
                if (!paths || paths.length === 0) return [];

                const validPaths = paths.map(p => this.validatePath(p)).filter(p => p.length > 0);
                if (validPaths.length === 0) return [];

                const ordered = [];
                const remaining = new Set(validPaths.map((_, i) => i));

                let currentPos = { x: 0, y: 0 };

                while (remaining.size > 0) {
                    let nearestIdx = -1;
                    let minDist = Infinity;
                    let reverseBest = false;

                    for (const idx of remaining) {
                        const path = validPaths[idx];
                        const start = path[0];
                        const end = path[path.length - 1];

                        if (!start || !end) continue;

                        const dStart = this.pointDistance(currentPos, start);
                        const dEnd = this.pointDistance(currentPos, end);

                        if (dStart < minDist) {
                            minDist = dStart;
                            nearestIdx = idx;
                            reverseBest = false;
                        }

                        if (dEnd < minDist) {
                            minDist = dEnd;
                            nearestIdx = idx;
                            reverseBest = true;
                        }
                    }

                    if (nearestIdx !== -1) {
                        let bestPath = validPaths[nearestIdx];
                        if (reverseBest) {
                            bestPath = [...bestPath].reverse();
                        }

                        ordered.push(bestPath);
                        currentPos = bestPath[bestPath.length - 1];
                        remaining.delete(nearestIdx);
                    } else {
                        break; // Should not happen
                    }
                }

                return ordered;
            }

            optimizePathOrder2Opt(paths) {
                if (!paths || paths.length < 2) return paths || [];

                const validPaths = paths.map(p => this.validatePath(p)).filter(p => p.length > 0);
                if (validPaths.length < 2) return validPaths;

                const n = validPaths.length;
                const maxIterations = Math.min(n * 2, 2000);

                const getPathEndpoints = (path) => ({
                    start: path[0],
                    end: path[path.length - 1]
                });

                const calculateTotalDistance = (ordered) => {
                    let dist = 0;
                    for (let i = 0; i < ordered.length - 1; i++) {
                        const currEnd = getPathEndpoints(ordered[i]).end;
                        const nextStart = getPathEndpoints(ordered[i + 1]).start;
                        dist += this.pointDistance(currEnd, nextStart);
                    }
                    return dist;
                };

                let bestOrder = [...validPaths];
                let bestDistance = calculateTotalDistance(bestOrder);

                for (let iter = 0; iter < maxIterations; iter++) {
                    let improved = false;

                    for (let i = 0; i < n - 1; i++) {
                        for (let j = i + 2; j < n; j++) {
                            const currentOrder = [...bestOrder];

                            const temp = currentOrder[i + 1];
                            currentOrder[i + 1] = currentOrder[j];
                            currentOrder[j] = temp;

                            const newDistance = calculateTotalDistance(currentOrder);

                            if (newDistance < bestDistance) {
                                bestOrder = currentOrder;
                                bestDistance = newDistance;
                                improved = true;
                            }
                        }
                    }

                    if (!improved) break;
                }

                return bestOrder;
            }

            async joinContoursImproved(rawContours, showProgress, options = {}) {
                // Extract options with new defaults for improved quality
                const contourSmoothness = options.contourSmoothness ?? 0.5;
                const simplification = options.simplification ?? 1.0; // RDP Epsilon (pixels)
                const optimizePath = options.optimizePath !== false; // Default true
                const minPathLength = options.minPathLength ?? 5; // Remove noise (pixels)
                const splineResolution = options.splineResolution ?? 4; // Points per segment

                const allSegments = [];
                for (const contour of rawContours) {
                    allSegments.push(...contour.lines);
                }

                const width = this.canvas.width;
                const height = this.canvas.height;
                const spatialIndex = this.buildSpatialIndex(allSegments, width, height);

                let paths = [];
                const used = new Set();
                const TOLERANCE = 2.0; 

                for (let i = 0; i < allSegments.length; i++) {
                    if (used.has(i)) continue;

                    let currentPath = [{ x: allSegments[i].x1, y: allSegments[i].y1 }];
                    const segmentRefs = [i];
                    used.add(i);
                    let currentEnd = { x: allSegments[i].x2, y: allSegments[i].y2 };

                    // Follow the path forward
                    while (true) {
                        const neighbors = spatialIndex.query(currentEnd.x, currentEnd.y, TOLERANCE);
                        let bestMatch = null;
                        let bestDist = Infinity;

                        for (const neighborIdx of neighbors) {
                            if (used.has(neighborIdx)) continue;
                            if (neighborIdx >= allSegments.length) continue;

                            const neighbor = allSegments[neighborIdx];
                            if (!neighbor) continue;

                            // Check if this segment connects to current end
                            const dist1 = this.pointDistance(currentEnd, { x: neighbor.x1, y: neighbor.y1 });
                            const dist2 = this.pointDistance(currentEnd, { x: neighbor.x2, y: neighbor.y2 });

                            if (dist1 < TOLERANCE && dist1 < bestDist) {
                                bestDist = dist1;
                                bestMatch = { idx: neighborIdx, reverse: false };
                            }
                            if (dist2 < TOLERANCE && dist2 < bestDist) {
                                bestDist = dist2;
                                bestMatch = { idx: neighborIdx, reverse: true };
                            }
                        }

                        if (!bestMatch) break;

                        const seg = allSegments[bestMatch.idx];
                        if (bestMatch.reverse) {
                            currentPath.push({ x: seg.x2, y: seg.y2 });
                        } else {
                            currentPath.push({ x: seg.x1, y: seg.y1 });
                        }

                        segmentRefs.push(bestMatch.idx);
                        used.add(bestMatch.idx);
                        currentEnd = bestMatch.reverse ? { x: seg.x1, y: seg.y1 } : { x: seg.x2, y: seg.y2 };
                    }

                    // Follow the path backward from start
                    let currentStart = currentPath[0];
                    while (true) {
                        const neighbors = spatialIndex.query(currentStart.x, currentStart.y, TOLERANCE);
                        let bestMatch = null;
                        let bestDist = Infinity;

                        for (const neighborIdx of neighbors) {
                            if (used.has(neighborIdx)) continue;
                            if (neighborIdx >= allSegments.length) continue;

                            const neighbor = allSegments[neighborIdx];
                            if (!neighbor) continue;

                            const dist1 = this.pointDistance(currentStart, { x: neighbor.x2, y: neighbor.y2 });
                            const dist2 = this.pointDistance(currentStart, { x: neighbor.x1, y: neighbor.y1 });

                            if (dist1 < TOLERANCE && dist1 < bestDist) {
                                bestDist = dist1;
                                bestMatch = { idx: neighborIdx, reverse: true };
                            }
                            if (dist2 < TOLERANCE && dist2 < bestDist) {
                                bestDist = dist2;
                                bestMatch = { idx: neighborIdx, reverse: false };
                            }
                        }

                        if (!bestMatch) break;

                        const seg = allSegments[bestMatch.idx];
                        if (bestMatch.reverse) {
                            currentPath.unshift({ x: seg.x1, y: seg.y1 });
                        } else {
                            currentPath.unshift({ x: seg.x2, y: seg.y2 });
                        }

                        segmentRefs.push(bestMatch.idx);
                        used.add(bestMatch.idx);
                        currentStart = bestMatch.reverse ? { x: seg.x2, y: seg.y2 } : { x: seg.x1, y: seg.y1 };
                    }

                    if (currentPath.length > 1) {
                         const validatedPath = this.validatePath(currentPath);
                         if (validatedPath.length > 1) {
                             paths.push(validatedPath);
                         }
                    }

                    if (paths.length % 100 === 0) {
                        this.updateProgress(showProgress, 80 + (paths.length / (allSegments.length / 10)) * 10, 'Joining paths...');
                        await this.checkPause();
                        await this.yieldToBrowser();
                    }
                }
                
                 // === NEW POST-PROCESSING PIPELINE (Centralized) ===
                 return this.postProcessPaths(paths, {
                     contourSmoothness,
                     simplification,
                     optimizePath,
                     minPathLength,
                     splineResolution
                 });
            }
        }

        // Page Visibility API to handle tab switching
        let isPageVisible = true;

        const handleVisibilityChange = () => {
            isPageVisible = !document.hidden;
            // Notify the marchingWaves instance of visibility change
            if (window.marchingWaves) {
                marchingWaves.pageVisibilityChanged(isPageVisible);
            }

            // Reset document title when tab becomes visible again
            if (isPageVisible) {
                // If not processing, reset to default title
                if (!isProcessing) {
                    document.title = 'Marching Waves Generator';
                } else {
                    // If processing, show that it's still working
                    document.title = 'Processing... | Marching Waves Generator';
                }
            }
        };

        document.addEventListener('visibilitychange', handleVisibilityChange, false);

        // Custom timeout function that works better with background tabs
        function backgroundAwareTimeout(callback, delay) {
            if (isPageVisible) {
                // When page is visible, use regular setTimeout
                return setTimeout(callback, delay);
            } else {
                // When page is hidden, use a more aggressive approach to ensure execution
                // This is still subject to browser throttling but may be more responsive
                return setTimeout(callback, delay);
            }
        }

        // Alternative approach using requestAnimationFrame which is more reliable
        function scheduleNextTick(callback) {
            // Use requestAnimationFrame if page is visible, otherwise setTimeout
            if (isPageVisible) {
                requestAnimationFrame(callback);
            } else {
                // Even when invisible, setTimeout will eventually execute (though throttled)
                setTimeout(callback, 0);
            }
        }

        const marchingWaves = new MarchingWaves();
        const selectionManager = new SelectionManager(
            document.getElementById('selectionOverlay'),
            document.getElementById('selectionBox'),
            document.getElementById('outputCanvas')
        );

        webGPUManager.init().then(available => {
            const statusEl = document.getElementById('gpuStatus');
            const statusText = document.getElementById('gpuStatusText');
            const statusIcon = document.getElementById('gpuStatusIcon');

            if (available) {
                console.log('WebGPU acceleration enabled (grayscale + Eikonal JFA)');
                statusEl.className = 'status success';
                statusText.textContent = 'ACTIVE (WebGPU)';
                statusIcon.textContent = 'âš¡';
            } else {
                console.log('Using CPU fallback (WebGPU not available)');
                statusEl.className = 'status warning';
                statusText.textContent = 'INACTIVE (CPU Fallback)';
                statusIcon.textContent = 'âš ï¸';
            }
        });

        // Initialize worker pool status
        if (typeof Worker !== 'undefined') {
            marchingWaves.initWorkerPool().then(success => {
                const workerStatusEl = document.getElementById('workerStatus');
                const workerStatusText = document.getElementById('workerStatusText');
                const workerStatusIcon = document.getElementById('workerStatusIcon');

                if (success && marchingWaves.workerPool) {
                    const stats = marchingWaves.workerPool.getStats();
                    console.log('Web Workers enabled for background processing', stats);
                    workerStatusEl.className = 'status success';
                    workerStatusText.textContent = `ACTIVE (${stats.totalWorkers} Workers)`;
                    workerStatusIcon.textContent = 'âš¡';

                    // Add visibility change listener for adaptive batch sizing
                    document.addEventListener('visibilitychange', () => {
                        const isVisible = !document.hidden;
                        marchingWaves.workerPool.broadcastVisibility(isVisible);
                    });

                    // Initial visibility state
                    if (!document.hidden) {
                        marchingWaves.workerPool.broadcastVisibility(true);
                    }
                } else {
                    console.log('Web Workers not available, using main thread');
                    workerStatusEl.className = 'status warning';
                    workerStatusText.textContent = 'INACTIVE (Main Thread Only)';
                    workerStatusIcon.textContent = 'âš ï¸';
                }
            }).catch(() => {
                const workerStatusEl = document.getElementById('workerStatus');
                const workerStatusText = document.getElementById('workerStatusText');
                const workerStatusIcon = document.getElementById('workerStatusIcon');
                workerStatusEl.className = 'status error';
                workerStatusText.textContent = 'FAILED (Main Thread Only)';
                workerStatusIcon.textContent = 'âŒ';
            });
        } else {
            const workerStatusEl = document.getElementById('workerStatus');
            const workerStatusText = document.getElementById('workerStatusText');
            const workerStatusIcon = document.getElementById('workerStatusIcon');
            workerStatusEl.className = 'status warning';
            workerStatusText.textContent = 'NOT SUPPORTED';
            workerStatusIcon.textContent = 'âš ï¸';
        }

        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const sampleBtn = document.getElementById('sampleBtn');
        const dropPreview = document.getElementById('dropPreview');
        const placeholder = document.getElementById('placeholder');
        const previewContainer = document.getElementById('previewContainer');
        const canvasContainer = document.getElementById('canvasContainer');
        const generateBtn = document.getElementById('generateBtn');
        const cancelBtnContainer = document.getElementById('cancelBtnContainer');
        const cancelBtn = document.getElementById('cancelBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const selectionBtn = document.getElementById('selectionBtn');
        const rerunBtn = document.getElementById('rerunBtn');
        const exportBtn = document.getElementById('exportBtn');
        const clearBtn = document.getElementById('clearBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const status = document.getElementById('status');
        const debugMode = document.getElementById('debugMode');
        const vizModeGroup = document.getElementById('vizModeGroup');
        const originGroup = document.getElementById('originGroup');
        const gridGroup = document.getElementById('gridGroup');
        const perfGroup = document.getElementById('perfGroup');
        const perfStats = document.getElementById('perfStats');

        let currentImage = null;
        let currentSVG = null;
        let isProcessing = false;

        const showStatus = (message, type) => {
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
            setTimeout(() => {
                if (status.textContent === message) {
                    status.style.display = 'none';
                }
            }, 5000);
        };

        const updateProgressUI = (show, percent, text) => {
            if (show) {
                progressContainer.style.display = 'block';
                progressFill.style.width = percent + '%';
                progressText.textContent = text;

                // Update document title with progress when tab is hidden to show activity
                if (!isPageVisible) {
                    const progressStr = percent >= 0 ? `[${percent.toFixed(0)}%] ` : '';
                    document.title = `${progressStr}Processing... | Marching Waves Generator`;

                    // Send notification when complete in background
                    if (percent >= 100) {
                        setTimeout(() => {
                            document.title = 'âœ“ Complete | Marching Waves Generator';

                            // Request notification permission and send notification
                            if ('Notification' in window && Notification.permission === 'granted') {
                                new Notification('Processing Complete!', {
                                    body: 'Your Marching Waves artwork is ready.',
                                    icon: 'ðŸŽ¨'
                                });
                            }
                        }, 1000);
                    }
                }
            } else {
                progressContainer.style.display = 'none';
            }
        };

        // Reset document title when processing is done (success or error)
        function resetDocumentTitle() {
            document.title = 'Marching Waves Generator';
        }

        // Request notification permission on first interaction
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    console.log(`Notification permission: ${permission}`);
                });
            }
        }

        // Add click listener to request permission
        document.addEventListener('click', requestNotificationPermission, { once: true });

        // Pause/Resume Logic
        pauseBtn.addEventListener('click', () => {
            marchingWaves.pause();
            pauseBtn.style.display = 'none';
            resumeBtn.style.display = 'block';
        });

        resumeBtn.addEventListener('click', () => {
            marchingWaves.resume();
            resumeBtn.style.display = 'none';
            pauseBtn.style.display = 'block';
        });

        // Selection Logic
        selectionBtn.addEventListener('click', () => {
            if (selectionManager.enabled) {
                selectionManager.disable();
                selectionBtn.textContent = 'Select Area to Rerun';
                selectionBtn.classList.remove('btn-primary');
                selectionBtn.classList.add('btn-secondary');
            } else {
                selectionManager.enable();
                selectionBtn.textContent = 'Cancel Selection';
                selectionBtn.classList.remove('btn-secondary');
                selectionBtn.classList.add('btn-primary');
                showStatus('Click and drag on the canvas to select an area', 'info');
            }
        });

        rerunBtn.addEventListener('click', async () => {
            if (!selectionManager.selection || isProcessing) return;
            
            isProcessing = true;
            generateBtn.disabled = true;
            rerunBtn.disabled = true;
            selectionManager.disable(); // Hide selection during processing
            selectionBtn.style.display = 'none';
            cancelBtnContainer.classList.add('visible');
            pauseBtn.style.display = 'block';
            resumeBtn.style.display = 'none';

            const options = {
                mode: document.getElementById('modeSelect').value,
                interval: parseFloat(document.getElementById('interval').value),
                lineWidth: parseFloat(document.getElementById('lineWidth').value),
                threshold: parseFloat(document.getElementById('threshold').value),
                invert: document.getElementById('invert').checked,
                lineColor: document.getElementById('lineColor').value,
                antiAlias: document.getElementById('antiAlias').checked,
                maxSegments: parseInt(document.getElementById('maxSegments').value),
                skipJoining: document.getElementById('skipJoining').checked,
                showProgress: document.getElementById('showProgress').checked,
                // ... adaptive params ...
                edgeGuidance: document.getElementById('edgeGuidance').checked,
                edgeSensitivity: parseFloat(document.getElementById('edgeSensitivity').value),
                detailLevel: parseFloat(document.getElementById('detailLevel').value),
                contourSmoothness: parseFloat(document.getElementById('contourSmoothness').value),
                featureImportance: parseFloat(document.getElementById('featureImportance').value),
                // Pass optimization params too
                simplification: presets[document.getElementById('presetSelect').value]?.simplification,
                splineResolution: presets[document.getElementById('presetSelect').value]?.splineResolution,
                optimizePath: presets[document.getElementById('presetSelect').value]?.optimizePath
            };

            marchingWaves.setProgressCallback(updateProgressUI);

            try {
                currentSVG = await marchingWaves.rerunRegion(selectionManager.selection, options);
                showStatus('Region updated successfully!', 'success');
            } catch (error) {
                if (error.message === 'Cancelled by user') {
                    showStatus('Operation cancelled', 'warning');
                    // Restore previous state if possible or just clear?
                } else {
                    console.error(error);
                    showStatus('Error: ' + error.message, 'error');
                }
            } finally {
                isProcessing = false;
                generateBtn.disabled = false;
                rerunBtn.disabled = false;
                selectionBtn.style.display = 'block';
                selectionBtn.textContent = 'Select Area to Rerun';
                selectionBtn.classList.add('btn-secondary');
                selectionBtn.classList.remove('btn-primary');
                rerunBtn.style.display = 'none'; // Hide rerun button after run
                cancelBtnContainer.classList.remove('visible');
                progressContainer.style.display = 'none';
            }
        });

        const presets = {
            'fluid': {
                mode: 'streamlines',
                interval: 5,
                lineWidth: 0.8,
                threshold: 50,
                lineColor: '#1a1a2e',
                invert: true,
                contourSmoothness: 1.0,
                simplification: 0.8
            },
            'cyberpunk': {
                mode: 'contours',
                interval: 15,
                lineWidth: 1.2,
                threshold: 60,
                lineColor: '#00ff99',
                invert: true,
                edgeGuidance: true,
                edgeSensitivity: 0.9,
                simplification: 0.2,
                contourSmoothness: 0.2
            },
            'ink-blot': {
                mode: 'stipple',
                interval: 4,
                lineWidth: 1.0,
                threshold: 30,
                lineColor: '#000000',
                invert: true
            },
            'ethereal': {
                mode: 'contours',
                interval: 4,
                lineWidth: 0.5,
                threshold: 20,
                lineColor: '#88ccff',
                invert: false,
                contourSmoothness: 0.9,
                detailLevel: 1.0
            },
            'sketch': {
                mode: 'hatch',
                interval: 8,
                lineWidth: 0.5,
                threshold: 50,
                lineColor: '#000000',
                invert: true,
                simplification: 0.5
            },
            'topo-map': {
                mode: 'contours',
                interval: 12,
                lineWidth: 1.0,
                threshold: 50,
                lineColor: '#1a1a1a',
                invert: true,
                edgeGuidance: false,
                contourSmoothness: 0.85
            },
            'blueprint': {
                mode: 'contours',
                interval: 8,
                lineWidth: 0.8,
                threshold: 45,
                lineColor: '#0055ff',
                invert: true,
                edgeGuidance: true,
                edgeSensitivity: 0.8
            },
            'flowing-silk': {
                mode: 'streamlines',
                interval: 6,
                lineWidth: 0.8,
                threshold: 45,
                lineColor: '#1a1a2e',
                invert: true,
                contourSmoothness: 0.95
            },
            'marble-flow': {
                mode: 'streamlines',
                interval: 10,
                lineWidth: 1.5,
                threshold: 50,
                lineColor: '#2c3e50',
                invert: true,
                contourSmoothness: 0.8
            },
            'ink-stipple': {
                mode: 'stipple',
                interval: 10,
                lineWidth: 1.0,
                threshold: 40,
                lineColor: '#000000',
                invert: true
            },
            'tangled-string': {
                mode: 'tsp',
                interval: 8,
                lineWidth: 0.5,
                threshold: 55,
                lineColor: '#000000',
                invert: true
            }
        };

        const applyPreset = (presetName) => {
            const preset = presets[presetName];
            if (!preset) return;

            if (preset.mode) {
                document.getElementById('modeSelect').value = preset.mode;
                // Trigger change event to update labels
                document.getElementById('modeSelect').dispatchEvent(new Event('change'));
            }

            document.getElementById('interval').value = preset.interval;
            document.getElementById('intervalValue').textContent = preset.interval;

            document.getElementById('lineWidth').value = preset.lineWidth;
            document.getElementById('lineWidthValue').textContent = preset.lineWidth.toFixed(1);

            document.getElementById('threshold').value = preset.threshold;
            document.getElementById('thresholdValue').textContent = preset.threshold;

            document.getElementById('lineColor').value = preset.lineColor;

            document.getElementById('invert').checked = preset.invert;
            document.getElementById('antiAlias').checked = preset.antiAlias;
            document.getElementById('maxSegments').value = preset.maxSegments;
            document.getElementById('maxSegValue').textContent = preset.maxSegments;

            // Apply new adaptive contour parameters if they exist
            if (preset.edgeGuidance !== undefined) {
                document.getElementById('edgeGuidance').checked = preset.edgeGuidance;
                document.getElementById('edgeSensitivity').value = preset.edgeSensitivity;
                document.getElementById('edgeSensitivityValue').textContent = preset.edgeSensitivity.toFixed(2);
                document.getElementById('detailLevel').value = preset.detailLevel;
                document.getElementById('detailLevelValue').textContent = preset.detailLevel.toFixed(2);
                document.getElementById('contourSmoothness').value = preset.contourSmoothness;
                document.getElementById('contourSmoothnessValue').textContent = preset.contourSmoothness.toFixed(2);
                document.getElementById('featureImportance').value = preset.featureImportance;
                document.getElementById('featureImportanceValue').textContent = preset.featureImportance.toFixed(2);
            }

            const presetLabel = document.getElementById('presetSelect').options[document.getElementById('presetSelect').selectedIndex].text;
            showStatus(`Applied preset: ${presetLabel}`, 'info');
        };

        document.getElementById('presetSelect').addEventListener('change', (e) => {
            const presetName = e.target.value;
            if (presetName !== 'custom') {
                applyPreset(presetName);
            }
        });

        document.getElementById('modeSelect').addEventListener('change', (e) => {
            const mode = e.target.value;
            const intervalLabel = document.querySelector('label[for="interval"]') || document.querySelector('.control-group label');
            // Find the label for interval - it's the first one in Parameters
            const labels = document.querySelectorAll('.panel:nth-child(2) .control-group label');
            if (labels[0]) {
                labels[0].textContent = mode === 'streamlines' ? 'Streamline Spacing' : 
                                        mode === 'stipple' || mode === 'tsp' ? 'Point Density' : 
                                        mode === 'hatch' ? 'Hatch Spacing' : 'Contour Interval';
            }
            
            // Show/Hide adaptive panels
            const adaptivePanel = document.querySelectorAll('.panel')[2];
            const performancePanel = document.querySelectorAll('.panel')[4];
            
            if (mode === 'streamlines' || mode === 'stipple' || mode === 'tsp' || mode === 'hatch') {
                adaptivePanel.style.display = 'none';
                // For performance, stipple/tsp don't use maxSegments the same way
                document.getElementById('maxSegments').closest('.control-group').style.display = 'none';
                document.getElementById('skipJoining').closest('.checkbox-group').style.display = 'none';
            } else {
                adaptivePanel.style.display = 'block';
                document.getElementById('maxSegments').closest('.control-group').style.display = 'block';
                document.getElementById('skipJoining').closest('.checkbox-group').style.display = 'block';
            }
        });

        const generateSamplePattern = () => {
            const canvas = document.createElement('canvas');
            const size = 200;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const centerX = size / 2;
            const centerY = size / 2;
            const maxRadius = size / 2 - 10;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    let value;
                    if (distance > maxRadius) {
                        value = 1;
                    } else {
                        value = distance / maxRadius;
                        value = Math.pow(value, 0.5);
                    }

                    const brightness = Math.floor((1 - value) * 255);
                    ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            const img = new Image();
            img.src = canvas.toDataURL();
            return img;
        };

        sampleBtn.addEventListener('click', () => {
            const sampleImg = generateSamplePattern();
            sampleImg.onload = () => {
                currentImage = sampleImg;
                dropPreview.src = sampleImg.src;
                dropPreview.style.display = 'block';
                placeholder.style.display = 'none';
                previewContainer.classList.add('has-image');
                canvasContainer.style.display = 'none';
                generateBtn.disabled = false;
                exportBtn.disabled = true;
                showStatus('Sample pattern loaded', 'info');
            };
        });

        cancelBtn.addEventListener('click', () => {
            marchingWaves.cancel();
            showStatus('Cancelling...', 'warning');
        });

        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadImage(file);
            }
        });

        const loadImage = (file) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    dropPreview.src = e.target.result;
                    dropPreview.style.display = 'block';
                    placeholder.style.display = 'none';
                    previewContainer.classList.add('has-image');
                    canvasContainer.style.display = 'none';
                    generateBtn.disabled = false;
                    exportBtn.disabled = true;
                    showStatus('Image loaded successfully', 'success');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        };

        debugMode.addEventListener('change', (e) => {
            const enabled = e.target.checked;
            vizModeGroup.style.display = enabled ? 'block' : 'none';
            originGroup.style.display = enabled ? 'flex' : 'none';
            gridGroup.style.display = enabled ? 'flex' : 'none';
            perfGroup.style.display = enabled ? 'flex' : 'none';
            perfStats.classList.toggle('visible', enabled && document.getElementById('showPerf').checked);
        });

        // New adaptive contour control listeners
        document.getElementById('edgeGuidance').addEventListener('change', (e) => {
            document.getElementById('edgeSensitivity').disabled = !e.target.checked;
        });

        document.getElementById('edgeSensitivity').addEventListener('input', (e) => {
            document.getElementById('edgeSensitivityValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('detailLevel').addEventListener('input', (e) => {
            document.getElementById('detailLevelValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('contourSmoothness').addEventListener('input', (e) => {
            document.getElementById('contourSmoothnessValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('featureImportance').addEventListener('input', (e) => {
            document.getElementById('featureImportanceValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('showPerf').addEventListener('change', (e) => {
            perfStats.classList.toggle('visible', e.target.checked);
        });

        generateBtn.addEventListener('click', async () => {
            if (!currentImage || isProcessing) return;

            isProcessing = true;
            generateBtn.disabled = true;
            cancelBtnContainer.classList.add('visible');
            pauseBtn.style.display = 'block';
            resumeBtn.style.display = 'none';
            selectionManager.clear(); // Clear any previous selection
            selectionBtn.style.display = 'none'; // Hide during generation
            exportBtn.disabled = true;
            progressContainer.style.display = 'block';
            
            // Set document title to indicate processing has started
            if (!isPageVisible) {
                document.title = 'Processing... | Marching Waves Generator';
            }

            const options = {
                mode: document.getElementById('modeSelect').value,
                interval: parseFloat(document.getElementById('interval').value),
                lineWidth: parseFloat(document.getElementById('lineWidth').value),
                threshold: parseFloat(document.getElementById('threshold').value),
                invert: document.getElementById('invert').checked,
                lineColor: document.getElementById('lineColor').value,
                antiAlias: document.getElementById('antiAlias').checked,
                maxSegments: parseInt(document.getElementById('maxSegments').value),
                skipJoining: document.getElementById('skipJoining').checked,
                showProgress: document.getElementById('showProgress').checked,
                debugMode: debugMode.checked,
                vizMode: document.getElementById('vizMode').value,
                showOrigins: document.getElementById('showOrigins').checked,
                showGrid: document.getElementById('showGrid').checked,
                livePreview: document.getElementById('livePreview').checked,
                useGPU: document.getElementById('useGPU').checked,
                useWorkers: document.getElementById('useWorkers').checked,
                // New adaptive contour parameters
                edgeGuidance: document.getElementById('edgeGuidance').checked,
                edgeSensitivity: parseFloat(document.getElementById('edgeSensitivity').value),
                detailLevel: parseFloat(document.getElementById('detailLevel').value),
                contourSmoothness: parseFloat(document.getElementById('contourSmoothness').value),
                featureImportance: parseFloat(document.getElementById('featureImportance').value),
                // Pass optimization params too
                simplification: presets[document.getElementById('presetSelect').value]?.simplification,
                splineResolution: presets[document.getElementById('presetSelect').value]?.splineResolution,
                optimizePath: presets[document.getElementById('presetSelect').value]?.optimizePath
            };

            marchingWaves.setProgressCallback(updateProgressUI);

            try {
                currentSVG = await marchingWaves.processImage(currentImage, options);

                dropPreview.style.display = 'none';
                canvasContainer.style.display = 'block';
                selectionBtn.style.display = 'block'; // Show after generation
                
                if (!debugMode.checked || options.vizMode === 'final') {
                    exportBtn.disabled = false;
                }

                if (marchingWaves.perf && Object.keys(marchingWaves.perf).length > 0) {
                    let statsText = 'Performance:\n';
                    for (const [key, value] of Object.entries(marchingWaves.perf)) {
                        statsText += `${key}: ${value}${typeof value === 'number' ? 'ms' : ''}\n`;
                    }
                    perfStats.textContent = statsText;
                }

                const modeName = debugMode.checked ? options.vizMode : 'final';
                showStatus(`Artwork generated (${modeName} view)`, 'success');
            } catch (error) {
                if (error.message === 'Cancelled by user') {
                    showStatus('Operation cancelled', 'warning');
                } else {
                    console.error(error);
                    showStatus('Error: ' + error.message, 'error');
                }
            } finally {
                isProcessing = false;
                generateBtn.disabled = false;
                cancelBtnContainer.classList.remove('visible');
                if (!exportBtn.disabled) {
                    progressContainer.style.display = 'none';
                }
                resetDocumentTitle();
            }
        });

        exportBtn.addEventListener('click', () => {
            if (!currentSVG) return;

            const blob = new Blob([currentSVG], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'marching-waves.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus('SVG exported successfully!', 'success');
        });

        clearBtn.addEventListener('click', () => {
            if (isProcessing) {
                marchingWaves.cancel();
            }
            currentImage = null;
            currentSVG = null;
            dropPreview.src = '';
            dropPreview.style.display = 'none';
            placeholder.style.display = 'block';
            previewContainer.classList.remove('has-image');
            canvasContainer.style.display = 'none';
            generateBtn.disabled = true;
            exportBtn.disabled = true;
            fileInput.value = '';
            progressContainer.style.display = 'none';
            status.style.display = 'none';
            marchingWaves.perf = {};
            perfStats.textContent = '';
        });

        document.getElementById('interval').addEventListener('input', (e) => {
            document.getElementById('intervalValue').textContent = e.target.value;
        });

        document.getElementById('lineWidth').addEventListener('input', (e) => {
            document.getElementById('lineWidthValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('threshold').addEventListener('input', (e) => {
            document.getElementById('thresholdValue').textContent = e.target.value;
        });

        document.getElementById('maxSegments').addEventListener('input', (e) => {
            document.getElementById('maxSegValue').textContent = e.target.value;
        });

        // Info icon tooltip handling for touch devices
        (function initInfoIcons() {
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

            if (isTouchDevice) {
                const infoIcons = document.querySelectorAll('.info-icon');
                let currentActiveIcon = null;

                infoIcons.forEach(icon => {
                    icon.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        // Toggle active state
                        if (currentActiveIcon && currentActiveIcon !== this) {
                            currentActiveIcon.classList.remove('active');
                        }

                        this.classList.toggle('active');
                        currentActiveIcon = this.classList.contains('active') ? this : null;
                    });
                });

                // Close tooltip when clicking outside
                document.addEventListener('click', function(e) {
                    if (currentActiveIcon && !e.target.classList.contains('info-icon')) {
                        currentActiveIcon.classList.remove('active');
                        currentActiveIcon = null;
                    }
                });
            }

            // Keyboard accessibility
            const infoIcons = document.querySelectorAll('.info-icon');
            infoIcons.forEach(icon => {
                icon.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        if (isTouchDevice) {
                            this.click();
                        }
                    }
                    if (e.key === 'Escape') {
                        this.classList.remove('active');
                        this.blur();
                    }
                });
            });
        })();

        // Create a Web Worker for intensive computations that can continue running in the background
        // This will help with processing when the tab is inactive
        function createProcessingWorker() {
            const workerCode = `
                // Worker for intensive computations
                self.onmessage = function(e) {
                    const { type, data } = e.data;

                    switch(type) {
                        case 'processContours':
                            // Simulate contour processing
                            const result = processContours(data);
                            self.postMessage({ type: 'result', data: result });
                            break;
                        case 'solveEikonal':
                            // Simulate Eikonal equation solving
                            const solution = solveEikonal(data);
                            self.postMessage({ type: 'result', data: solution });
                            break;
                        default:
                            self.postMessage({ type: 'error', message: 'Unknown operation' });
                    }
                };

                function processContours(data) {
                    // Simulate contour processing work
                    const { width, height, interval, maxSegments } = data;

                    // This is a simplified simulation - in a real implementation,
                    // this would contain the actual contour processing algorithm
                    const startTime = Date.now();
                    let segmentsProcessed = 0;

                    // Simulate processing work
                    for (let i = 0; i < maxSegments && (Date.now() - startTime) < 1000; i++) {
                        segmentsProcessed++;
                        // Simulate some computation
                        Math.random() * width * height;
                    }

                    return {
                        segmentsProcessed,
                        timeElapsed: Date.now() - startTime,
                        completed: segmentsProcessed >= maxSegments
                    };
                }

                function solveEikonal(data) {
                    // Simulate Eikonal equation solving
                    const { width, height, threshold } = data;

                    const startTime = Date.now();
                    let cellsProcessed = 0;

                    // Simulate solving work
                    for (let y = 0; y < height && (Date.now() - startTime) < 1000; y++) {
                        for (let x = 0; x < width; x++) {
                            cellsProcessed++;
                            // Simulate some computation
                            const val = Math.sqrt(x*x + y*y);
                            if (val < threshold * 100) {
                                // Some processing
                            }
                        }
                    }

                    return {
                        cellsProcessed,
                        timeElapsed: Date.now() - startTime,
                        completed: cellsProcessed >= width * height
                    };
                }
            `;

            const blob = new Blob([workerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // Initialize worker if supported
        let processingWorker = null;
        if (window.Worker) {
            processingWorker = createProcessingWorker();

            // Handle messages from worker
            processingWorker.onmessage = function(e) {
                const { type, data } = e.data;

                if (type === 'result') {
                    console.log('Worker result:', data);
                    // Update UI or continue processing based on result
                } else if (type === 'error') {
                    console.error('Worker error:', data.message);
                }
            };

            // Handle worker errors
            processingWorker.onerror = function(error) {
                console.error('Worker error:', error);
            };
        }

        // Function to offload intensive computation to worker
        function offloadToWorker(taskType, taskData) {
            if (processingWorker) {
                processingWorker.postMessage({ type: taskType, data: taskData });
                return true;
            }
            return false;
        }

        // Update MarchingWaves to use workers when possible
        if (window.marchingWaves) {
            // Add method to use worker for intensive tasks
            marchingWaves.offloadComputation = function(taskType, taskData) {
                return offloadToWorker(taskType, taskData);
            };
        }

        // Test function to verify tab switching functionality
        function testTabSwitching() {
            console.log('Testing tab switching functionality...');

            // Simulate the visibility change
            console.log('Current visibility state:', isPageVisible);
            console.log('Page title:', document.title);

            // This function can be expanded to perform more comprehensive tests
            console.log('Tab switching functionality test completed.');
        }

        // Expose test function globally for manual testing
        window.testTabSwitching = testTabSwitching;
    </script>
</body>
</html>